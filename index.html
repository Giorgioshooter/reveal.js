<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JS London Conference</title>

		<meta name="description" content="A summary of Thursdays events!">
		<meta name="author" content="Georgios Galatoulas">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>London JS Conference</h1>
					<h3>Key Points</h3>
					<p>
						<small>Created by <a href="http://github.org/GiorgioShooter">Georgios Galatoulas</a> / <a href="http://twitter.com/gioshooter">@GioShooter</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>Touch Events</h2>

						<p>
							Author : Peter-Paul Koch
						</p>

						<p>
							how different our approach is on touch based devices and how each browser behaves
						</p>
					</section>
					<section>
						<h4>Touch or click</h4>
						<p>
							The safest way is the use of 'click' event, but... 
						</p>
						<p class="fragment">what about speed?</p>
						<p class="fragment">
							It is known that the click has a 300ms delay to determine if it is a doubleclick event.
							This is in terms of responsiveness the mininum time we need to react in order the user 
							to stay engaged which is gone by already by waiting for something else. 
						</p>
					</section>
					<section>
						<h4>Touch or click</h4>
						<p> 
							So use the touchstart instead.
						</p>
						<p class="fragment">
							Which means anything, swipe , tap, zoom and so on.
						</p>
						<p class="fragment">
							That is why when we design for touch based devices we need to be clear on the responsibilities.
						</p>
					</section>
					<section>
						<h4>Event Cascade</h4
						<p class="fragment">
							Every tap has a sequence of events. for example a tap fires
						</p>
						<ul>
							<li class="fragment">touchstart</li>
							<li class="fragment">touchend</li>
							<li class="fragment">mouseover</li>
							<li class="fragment">mousemove</li>
							<li class="fragment">mousedown</li>
							<li class="fragment">mouseup</li>
							<li class="fragment"><b>click</b></li>
							<li class="fragment">:hover styles apply (!??)</li>
						</ul>
						<aside class="notes">
							<p> single tap : </p>
							<p> event list is touchstart touchend mouseover mousemove mousedown mouseup click and then the :hover applies.</p>
							<p> Everything else than a single tap : </p>
							<p> touchstart touchmove touchend and the a possible interaction on the element </p>
							<p> Tap an other element means the mouseout event and the :hover styles are removed</p>
						</aside>
					</section>
					<section>
						<h4> 
							Fun Fact about Safari
						</h4>
						<ul>
						<li class="fragment">
							On event chage the event cascade stops after mousemove 
						</li>
						<li class="fragment">
							Also content change in safari is when DOM methods are used .appendChild() but innerHTML is not count.
						</li>
						</ul>
					</section>
					<section>
						<h4>So Do we need each action to has its own event?</h4>
						<p class="fragment">So far as anyone concern yes</p>
						<p class="fragment"> But Microsoft merges basic events of touch and mouse to one pointer type event</p>
						<p class="fragment"> So both actions could have for example pointedown pointermove and pointerup events only.</p>
						<p class="fragment"> However the currently Microsoft's drag and Drop action based on the pointer events needs a help of CSS which it so optimal </p>
					</section>
					<section>
						<h4>Hover</h4>
						<p class="fragment">No need to be in touch events since it is not a continous event</p>
					</section>
					<section>
						<h4>Gestures</h4>
						<p class="fragment">Good Idea, not so usable cause of the lack of browser support (apple offers them)</p>
						<p class="fragment">However Microsof has bigger list of events but ... <spa class="fragment"> <b>they work only with a horific code.</b></span></p>
					</section>
			</section>
			<section>
				<section>
					<h2>Web Components</h2>
					<p>
						Author : Addy Osmani
					</p>
					<p>
						How we can change and improve the semantic web by creating meaningfull web components with their own attributes.
					</p>
				</section>
				<section>
					<h4> What is a web Component? </h4>
					<p class="fragment"> A tag that it has its own functions, properties and attributes.</p>
					<p class="fragment"> Also its name describe explicilty its purpose</p>
				</section>
				<section>
					<h4>Quick example of a custom web component</h4>
						<div class="exibitA"> 
							<pre>
								<code data-trim contenteditable>
<div id="tab-panel">
	<ul>
	    <li id="tab1">Tab 1</li>
	    <li id="tab2">Tab 2</li>
	</ul>
	<div id="contentTab1"></div>
	<div id="contentTab2"></div>
</div>
								</code>
							</pre>

						</div>
						<div class="exibitB"> 
							<pre>
								<code data-trim contenteditable>
<my-tabs>
	<my-tab> ... </my-tab>
	<my-tab> ... </my-tab>
</my-tabs>
								</code>
							</pre>

						</div>
				</section>
				<section>
					<h3>Philosophy</h3>
					<ul>
						<li class="fragment"> Everything is an Element </li>
						<li class="fragment"> Stop BoilerPlate code </li>
						<li class="fragment"> Utilize the mordern web platform </li>
					</ul>

				</section>
				<section>
					<h4>The Polymer Project</h4>
					<a href="http://www.polymer-project.org/">http://www.polymer-project.org/</a>
					<p> This project provides the infrastructure to create custom web elements for the application</p>
					<p> Their target is to have everything on Native support.</p>
					<p> So far they work only with polyfils to support all modern browsers</p>
				</section>
				<section>
					<h4>Browser compartibility</h4>
					<img src="img/browserComp.png" alt="browser Compartibility"></img>
				</section>
			</section>
			<section>
				<section>
					<h2>Online Optional</h2>

					<p>Author : Jake Archibald</p>

					<p>Web Apps that work offline</p>
				</section>
				<section>
					<h3>Basic Idea</h3>
					<p>
						Access the web app offline. Update only when we have to.
					</p>
					<p class="fragment">
						This can be provided by Appcache.
					</p>
					<p class="fragment">
						But Appcache is like a black box with  huge specs and no way to debug your configuration.
					</p>
				</section>
				<section>
					<h3>Service Workers</h3>
					<p class="fragment">
						It is a specification which gives the developer the tools he needs to 
						handle the web application in offline mode.
					</p>
					<p class="fragment">
						There are like share workers. They work in the background and they serve the pages.
					</p>
					<p class="fragment">
						The advantage of service workers is that the we have full control of the cache and we can 
						gracefully fail the network errors.
					</p>
				</section>
				<section>
					<h3> Graceful Decredation </h3>
					<p class="fragment"> To check data from the internet we need</p>
					<p class="fragment"> radio to start </p>
					<p class="fragment"> connect to the isp</p>
					<p class="fragment"> and then a whole traceroute until we get response</p>
					<p class="fragment"> if it fails then you get from the cache</p>
				</section>
				<section>
					<h3> What about the opposite ? </h3>
					<p class="fragment"> To check data from the cache </p>
					<p class="fragment"> show anything that it ok to show without internet,</p>
					<p class="fragment"> then if there is a new content then it fetches it and updates the web app</p>
					<p class="fragment"> just like the native apps they do</p>
				</section>
				<section>
					<h3> Browsers</h3>
					<p class="fragment"> It is still a spec not a full functional service</p>
					<p class="fragment"> So far Chome and Mozilla are working together on this.</p>
					<p class="fragment"> IE has concerns...</p>
					<p class="fragment"> Safari ... no answer yet</p>
					<p class="fragment"> Soon it will be in Canary</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Security Audit and Penetration Testing</h2>

					<p>
						Author : Joe Petterson
					</p>

					<p>
						The importance of Security audit and penetration Testing
					</p>
				</section>
				<section>
					<h2>Problem : the Client Enviroment </h2>
					<p> Every single Web application runs on unstrustworthy enviroment since we do not have control over it.</p>
					<p> The problem nowadays is worse since there not many pages that do not contain client logic.</p>
					<p> Most of them contain contain heavy JavaScipt modules to provide rich experience on the Client side.</p>
					<p> The server provides services to the JavaScript application.</p>
				</section>
				<section>
					<p> The Client should not assume at any case that the source is trustworthy.</p>
					<p> This is how attacks like Generic stored/Reflected XSS attacks applied.</p>
					<p> This is caused because in an MVC model for example a View can trust any source of data the model can send.</p>
					<p> solution: any DOM interaction should be sanitised even if the source is our server</p>
				</section>
				<section>
					<h4>Client side attacks</h4>
					<ul>
						<li class="fragment">Content spoofing</li>
						<li class="fragment">Cross Site Scripting (stored/persistent reflected/Non-persistent/DOM based)</li>
						<li class="fragment">Cross Site request Forgery</li>
						<li class="fragment">Information disclosure/leakage</li>
						<li class="fragment">Path travesal attacks</li>
						<li class="fragment">Authentication attacks</li>
						<li class="fragment">Cache poisoning</li>
						<li class="fragment"> ... </li>
					</ul>
				</section>
				<section>
					<h4>Client side attacks</h4>
					<ul>
						<li class="fragment">Never put not whitelisted data into your HMTL </li>
						<li class="fragment">Escape untrusted Data that are added into any HTML component</li>
						<li class="fragment">Escape everything non-alphanumenic inside HTML attributes</li>
						<li class="fragment">Put inside quotes JavaScript Generated untrusted data after it has been excaped or enconded</li>
						<li class="fragment">Avoid eval() even implicit ones</li>
						<li class="fragment">HTML excape JSON Values in an HMTL context and read the Data with JOSN parse</li>
						<li class="fragment">Use HTTP-ONLY Flag on cookies</li>
						<li class="fragment">Implement Content Security Policy</li>
					</ul>
					<aside class="notes">
					Not escaping attributes that are likely to be executed like href, src, handlers inline.
					Third rule is needed because a lot of people write the attributes without the code
					Beware eva(), Function("String"), setInterval("")...
					</aside>
				</section>
					<section>
					<pre>
						<code data-trim contenteditable>
	var x = document.createElement("a"),
	    y =document.createTextNode();
	x.href = "x";
	x.setAttribute("onlcick", "\u0061\u006c\0067..../");// cleary Malicious intentions
	y.appendChild(x)
						</code>
					</pre>

				</section>
				<section>
					<h4>HTML5 APIs</h4>
					<p>We need to know from which server we get the response</p>
					<p>We do not need to allow the attacker have a easy way to send back a false response.</p>
					<p>Especially in CORS we need to validate all the urls we pass through</p>
					<p>No wildcard in Access-Control-Allow-Origin !</p>
					<p>localstorage in not secure enough we are better of using the sessionStorage.</p>
					<p>Be aware of cache poisoning if the items are cached in localstorage.</p>
					<p>DOS with web workers</p>
					<p>Sandboxing untrusted data with sandbox</p>
					<p>Prevent cache poisoning in man in the middle attacks. Solution is HTTPS.</p>
					<p>With WebGL the attacket is able to block the GPU causing DOS. </p>
				</section>
				<section>
					<h4> How are we sure that we have a secure web application?</h4>
					<ul>
						<li class="fragment">Audit tests</li>
					</ul>
				</section>
				<section>
					<h4>what we can achieve with auditing</h4>
					<ul>
						<li class="fragment">Find the intergration points</li>
						<li class="fragment">Breath and Depth of attack surface</li>
						<li class="fragment">Trust boundries</li>
						<li class="fragment">Security implications base on selected technology</li>
					</ul>
					<p class="fragment">At any case any web application should have run vunerability tests (for example Metaexpoit tool)</p>
					<p class="fragment">CI builds</p>
				</section>
				<section>
					<h4> Penetration Testing </h4>
					<ul>
						<li>Manual testing</li>
						<li>Leverage Profetional experience</li>
						<li>Methodologies</li>
						<li>Reports</li>
						<li>People ! (no one is better that a man)</li>
					</ul>
					<aside class="notes">
						<ol>
							<li class="fragment"> Establish goals</li>
							<li class="fragment"> Reconnaissance</li>
							<li class="fragment"> Discovery</li>
							<li class="fragment"> Exploitation</li>
							<li class="fragment"> Brute forsing</li>
							<li class="fragment"> Social Engineering</li>
							<li class="fragment"> Taking Control</li>
							<li class="fragment"> Pivoting</li>
							<li class="fragment"> Evidence collection</li>
							<li class="fragment"> Reporting</li>
							<li class="fragment"> Remediation</li>
					</aside>
				</section>
				<section>
					<h4> Penetration Testing </h4>
					<ul>
						<li>Must run on an enviroment that provides as accurate environment as posible (db replicas and NDA's)</li>
						<li> Beware about the scope of the test.<li>
							<li>The best pen tester is usually external </li>
					</ul>
				</section>
			</section>
			
			<section>
				<section>
					<h2>Multi-Device Interfaces</h2>
					<p>Author : Benjamin Foxall</p>
					<p>
						Designing for multiple Devices and how we can exploit each Device capabilities for 
						enhanced experience
					</p>
				</section>
				<section>
					<h3> We have many devices out there! </h3>
					<p>A lot of support</p>
					<p class="fragment">But it is also a good thing!</p>
					<aside class="notes">
						camera can take photos
					</aside>
				</section>
				<section>
					<h3> Designing for multiple devices and screen sizes</h3>
					<p class="fragment"> Identify device capabilities</p>
					<p class="fragment"> Adapt our web application to the device</p>
					<p class="fragment"> Example: An audio web app in a touch device has the ability to change two sliders at once instead of one in the desktop version</p>
				</section>
				<section>
					<h3> Tools </h3>
					<p class="fragment"> Mondernizr for HTML5 and CCS3 detection !</p>
					<aside class="notes">
						<p > 
							AppCache, battery, CSS animation/trnsforms/3D, Device Orientation
							Drag and Drop, FullScreen, Geolocation, IndexDB, Touch Events,
							webSocket, WebRTC, Webworkers
						</p>
					</aside>
				</section>
				<section>
					<h3>Transpots</h3>
					<p class="fragment"> Different Devices communicate with each other or the main server</p>
					<p class="fragment"> Subscribe and publish</p>
					<p class="fragment"> Reat time transfer</p>
					<p class="fragment"> Web Sockets and webRTC</p>
				</section>
				<section>
					<h3>WebSockets</h3>
					<p class="fragment"> bidirection communication with server and client</p>
					<p class="fragment"> single handshake and the the connection stays alive</p>
					<p class="fragment"> Server publishes a message and the client receives it without big delays</p>
				</section>
				<section>
					<h3>WebRTC</h3>
					<p class="fragment"> Protocol for peet to peer client communication</p>
					<p class="fragment"> MediaStream, RTCPeerConnection, RTCDataChannels</p>
					<p class="fragment"> quicker reaction on events</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Regular expressions explained</h2>
					<p>Author : Lea Verou</p>
					<p>
						Mostly a workshop explaining by example most of the possible rules we may need in JavaScript 
						for regular expressions.
					</p>
					<p>
						for the curious her  
						<a href="http://lea.verou.me/regexplained/slides.html#slide8"> slides </a>
						contain a proper regex test page where you can start practice your skills
  					</p>
				</section>
			</section>
			<section>
				<section>
					<h1>Thank you</h1>
				</section>
			</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
